// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mock

import (
	"archive/tar"
	"context"
	"io"
	"sync"

	"github.com/FuturFusion/operations-center/internal/provisioning"
)

// Ensure that UpdateSourceWithAddPortMock does implement provisioning.UpdateSourceWithAddPort.
// If this is not the case, regenerate this file with mockery.
var _ provisioning.UpdateSourceWithAddPort = &UpdateSourceWithAddPortMock{}

// UpdateSourceWithAddPortMock is a mock implementation of provisioning.UpdateSourceWithAddPort.
//
//	func TestSomethingThatUsesUpdateSourceWithAddPort(t *testing.T) {
//
//		// make and configure a mocked provisioning.UpdateSourceWithAddPort
//		mockedUpdateSourceWithAddPort := &UpdateSourceWithAddPortMock{
//			AddFunc: func(ctx context.Context, tarReader *tar.Reader) (*provisioning.Update, error) {
//				panic("mock out the Add method")
//			},
//			ForgetUpdateFunc: func(ctx context.Context, update provisioning.Update) error {
//				panic("mock out the ForgetUpdate method")
//			},
//			GetLatestFunc: func(ctx context.Context, limit int) (provisioning.Updates, error) {
//				panic("mock out the GetLatest method")
//			},
//			GetUpdateAllFilesFunc: func(ctx context.Context, update provisioning.Update) (provisioning.UpdateFiles, error) {
//				panic("mock out the GetUpdateAllFiles method")
//			},
//			GetUpdateFileByFilenameFunc: func(ctx context.Context, update provisioning.Update, filename string) (io.ReadCloser, int, error) {
//				panic("mock out the GetUpdateFileByFilename method")
//			},
//		}
//
//		// use mockedUpdateSourceWithAddPort in code that requires provisioning.UpdateSourceWithAddPort
//		// and then make assertions.
//
//	}
type UpdateSourceWithAddPortMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(ctx context.Context, tarReader *tar.Reader) (*provisioning.Update, error)

	// ForgetUpdateFunc mocks the ForgetUpdate method.
	ForgetUpdateFunc func(ctx context.Context, update provisioning.Update) error

	// GetLatestFunc mocks the GetLatest method.
	GetLatestFunc func(ctx context.Context, limit int) (provisioning.Updates, error)

	// GetUpdateAllFilesFunc mocks the GetUpdateAllFiles method.
	GetUpdateAllFilesFunc func(ctx context.Context, update provisioning.Update) (provisioning.UpdateFiles, error)

	// GetUpdateFileByFilenameFunc mocks the GetUpdateFileByFilename method.
	GetUpdateFileByFilenameFunc func(ctx context.Context, update provisioning.Update, filename string) (io.ReadCloser, int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TarReader is the tarReader argument value.
			TarReader *tar.Reader
		}
		// ForgetUpdate holds details about calls to the ForgetUpdate method.
		ForgetUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Update is the update argument value.
			Update provisioning.Update
		}
		// GetLatest holds details about calls to the GetLatest method.
		GetLatest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int
		}
		// GetUpdateAllFiles holds details about calls to the GetUpdateAllFiles method.
		GetUpdateAllFiles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Update is the update argument value.
			Update provisioning.Update
		}
		// GetUpdateFileByFilename holds details about calls to the GetUpdateFileByFilename method.
		GetUpdateFileByFilename []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Update is the update argument value.
			Update provisioning.Update
			// Filename is the filename argument value.
			Filename string
		}
	}
	lockAdd                     sync.RWMutex
	lockForgetUpdate            sync.RWMutex
	lockGetLatest               sync.RWMutex
	lockGetUpdateAllFiles       sync.RWMutex
	lockGetUpdateFileByFilename sync.RWMutex
}

// Add calls AddFunc.
func (mock *UpdateSourceWithAddPortMock) Add(ctx context.Context, tarReader *tar.Reader) (*provisioning.Update, error) {
	if mock.AddFunc == nil {
		panic("UpdateSourceWithAddPortMock.AddFunc: method is nil but UpdateSourceWithAddPort.Add was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		TarReader *tar.Reader
	}{
		Ctx:       ctx,
		TarReader: tarReader,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	return mock.AddFunc(ctx, tarReader)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedUpdateSourceWithAddPort.AddCalls())
func (mock *UpdateSourceWithAddPortMock) AddCalls() []struct {
	Ctx       context.Context
	TarReader *tar.Reader
} {
	var calls []struct {
		Ctx       context.Context
		TarReader *tar.Reader
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// ForgetUpdate calls ForgetUpdateFunc.
func (mock *UpdateSourceWithAddPortMock) ForgetUpdate(ctx context.Context, update provisioning.Update) error {
	if mock.ForgetUpdateFunc == nil {
		panic("UpdateSourceWithAddPortMock.ForgetUpdateFunc: method is nil but UpdateSourceWithAddPort.ForgetUpdate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Update provisioning.Update
	}{
		Ctx:    ctx,
		Update: update,
	}
	mock.lockForgetUpdate.Lock()
	mock.calls.ForgetUpdate = append(mock.calls.ForgetUpdate, callInfo)
	mock.lockForgetUpdate.Unlock()
	return mock.ForgetUpdateFunc(ctx, update)
}

// ForgetUpdateCalls gets all the calls that were made to ForgetUpdate.
// Check the length with:
//
//	len(mockedUpdateSourceWithAddPort.ForgetUpdateCalls())
func (mock *UpdateSourceWithAddPortMock) ForgetUpdateCalls() []struct {
	Ctx    context.Context
	Update provisioning.Update
} {
	var calls []struct {
		Ctx    context.Context
		Update provisioning.Update
	}
	mock.lockForgetUpdate.RLock()
	calls = mock.calls.ForgetUpdate
	mock.lockForgetUpdate.RUnlock()
	return calls
}

// GetLatest calls GetLatestFunc.
func (mock *UpdateSourceWithAddPortMock) GetLatest(ctx context.Context, limit int) (provisioning.Updates, error) {
	if mock.GetLatestFunc == nil {
		panic("UpdateSourceWithAddPortMock.GetLatestFunc: method is nil but UpdateSourceWithAddPort.GetLatest was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int
	}{
		Ctx:   ctx,
		Limit: limit,
	}
	mock.lockGetLatest.Lock()
	mock.calls.GetLatest = append(mock.calls.GetLatest, callInfo)
	mock.lockGetLatest.Unlock()
	return mock.GetLatestFunc(ctx, limit)
}

// GetLatestCalls gets all the calls that were made to GetLatest.
// Check the length with:
//
//	len(mockedUpdateSourceWithAddPort.GetLatestCalls())
func (mock *UpdateSourceWithAddPortMock) GetLatestCalls() []struct {
	Ctx   context.Context
	Limit int
} {
	var calls []struct {
		Ctx   context.Context
		Limit int
	}
	mock.lockGetLatest.RLock()
	calls = mock.calls.GetLatest
	mock.lockGetLatest.RUnlock()
	return calls
}

// GetUpdateAllFiles calls GetUpdateAllFilesFunc.
func (mock *UpdateSourceWithAddPortMock) GetUpdateAllFiles(ctx context.Context, update provisioning.Update) (provisioning.UpdateFiles, error) {
	if mock.GetUpdateAllFilesFunc == nil {
		panic("UpdateSourceWithAddPortMock.GetUpdateAllFilesFunc: method is nil but UpdateSourceWithAddPort.GetUpdateAllFiles was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Update provisioning.Update
	}{
		Ctx:    ctx,
		Update: update,
	}
	mock.lockGetUpdateAllFiles.Lock()
	mock.calls.GetUpdateAllFiles = append(mock.calls.GetUpdateAllFiles, callInfo)
	mock.lockGetUpdateAllFiles.Unlock()
	return mock.GetUpdateAllFilesFunc(ctx, update)
}

// GetUpdateAllFilesCalls gets all the calls that were made to GetUpdateAllFiles.
// Check the length with:
//
//	len(mockedUpdateSourceWithAddPort.GetUpdateAllFilesCalls())
func (mock *UpdateSourceWithAddPortMock) GetUpdateAllFilesCalls() []struct {
	Ctx    context.Context
	Update provisioning.Update
} {
	var calls []struct {
		Ctx    context.Context
		Update provisioning.Update
	}
	mock.lockGetUpdateAllFiles.RLock()
	calls = mock.calls.GetUpdateAllFiles
	mock.lockGetUpdateAllFiles.RUnlock()
	return calls
}

// GetUpdateFileByFilename calls GetUpdateFileByFilenameFunc.
func (mock *UpdateSourceWithAddPortMock) GetUpdateFileByFilename(ctx context.Context, update provisioning.Update, filename string) (io.ReadCloser, int, error) {
	if mock.GetUpdateFileByFilenameFunc == nil {
		panic("UpdateSourceWithAddPortMock.GetUpdateFileByFilenameFunc: method is nil but UpdateSourceWithAddPort.GetUpdateFileByFilename was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Update   provisioning.Update
		Filename string
	}{
		Ctx:      ctx,
		Update:   update,
		Filename: filename,
	}
	mock.lockGetUpdateFileByFilename.Lock()
	mock.calls.GetUpdateFileByFilename = append(mock.calls.GetUpdateFileByFilename, callInfo)
	mock.lockGetUpdateFileByFilename.Unlock()
	return mock.GetUpdateFileByFilenameFunc(ctx, update, filename)
}

// GetUpdateFileByFilenameCalls gets all the calls that were made to GetUpdateFileByFilename.
// Check the length with:
//
//	len(mockedUpdateSourceWithAddPort.GetUpdateFileByFilenameCalls())
func (mock *UpdateSourceWithAddPortMock) GetUpdateFileByFilenameCalls() []struct {
	Ctx      context.Context
	Update   provisioning.Update
	Filename string
} {
	var calls []struct {
		Ctx      context.Context
		Update   provisioning.Update
		Filename string
	}
	mock.lockGetUpdateFileByFilename.RLock()
	calls = mock.calls.GetUpdateFileByFilename
	mock.lockGetUpdateFileByFilename.RUnlock()
	return calls
}
