// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mock

import (
	"context"
	"io"
	"sync"

	"github.com/FuturFusion/operations-center/internal/provisioning"
)

// Ensure that UpdateSourcePortMock does implement provisioning.UpdateSourcePort.
// If this is not the case, regenerate this file with mockery.
var _ provisioning.UpdateSourcePort = &UpdateSourcePortMock{}

// UpdateSourcePortMock is a mock implementation of provisioning.UpdateSourcePort.
//
//	func TestSomethingThatUsesUpdateSourcePort(t *testing.T) {
//
//		// make and configure a mocked provisioning.UpdateSourcePort
//		mockedUpdateSourcePort := &UpdateSourcePortMock{
//			ForgetUpdateFunc: func(ctx context.Context, update provisioning.Update) error {
//				panic("mock out the ForgetUpdate method")
//			},
//			GetLatestFunc: func(ctx context.Context, limit int) (provisioning.Updates, error) {
//				panic("mock out the GetLatest method")
//			},
//			GetUpdateAllFilesFunc: func(ctx context.Context, update provisioning.Update) (provisioning.UpdateFiles, error) {
//				panic("mock out the GetUpdateAllFiles method")
//			},
//			GetUpdateFileByFilenameFunc: func(ctx context.Context, update provisioning.Update, filename string) (io.ReadCloser, int, error) {
//				panic("mock out the GetUpdateFileByFilename method")
//			},
//		}
//
//		// use mockedUpdateSourcePort in code that requires provisioning.UpdateSourcePort
//		// and then make assertions.
//
//	}
type UpdateSourcePortMock struct {
	// ForgetUpdateFunc mocks the ForgetUpdate method.
	ForgetUpdateFunc func(ctx context.Context, update provisioning.Update) error

	// GetLatestFunc mocks the GetLatest method.
	GetLatestFunc func(ctx context.Context, limit int) (provisioning.Updates, error)

	// GetUpdateAllFilesFunc mocks the GetUpdateAllFiles method.
	GetUpdateAllFilesFunc func(ctx context.Context, update provisioning.Update) (provisioning.UpdateFiles, error)

	// GetUpdateFileByFilenameFunc mocks the GetUpdateFileByFilename method.
	GetUpdateFileByFilenameFunc func(ctx context.Context, update provisioning.Update, filename string) (io.ReadCloser, int, error)

	// calls tracks calls to the methods.
	calls struct {
		// ForgetUpdate holds details about calls to the ForgetUpdate method.
		ForgetUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Update is the update argument value.
			Update provisioning.Update
		}
		// GetLatest holds details about calls to the GetLatest method.
		GetLatest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int
		}
		// GetUpdateAllFiles holds details about calls to the GetUpdateAllFiles method.
		GetUpdateAllFiles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Update is the update argument value.
			Update provisioning.Update
		}
		// GetUpdateFileByFilename holds details about calls to the GetUpdateFileByFilename method.
		GetUpdateFileByFilename []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Update is the update argument value.
			Update provisioning.Update
			// Filename is the filename argument value.
			Filename string
		}
	}
	lockForgetUpdate            sync.RWMutex
	lockGetLatest               sync.RWMutex
	lockGetUpdateAllFiles       sync.RWMutex
	lockGetUpdateFileByFilename sync.RWMutex
}

// ForgetUpdate calls ForgetUpdateFunc.
func (mock *UpdateSourcePortMock) ForgetUpdate(ctx context.Context, update provisioning.Update) error {
	if mock.ForgetUpdateFunc == nil {
		panic("UpdateSourcePortMock.ForgetUpdateFunc: method is nil but UpdateSourcePort.ForgetUpdate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Update provisioning.Update
	}{
		Ctx:    ctx,
		Update: update,
	}
	mock.lockForgetUpdate.Lock()
	mock.calls.ForgetUpdate = append(mock.calls.ForgetUpdate, callInfo)
	mock.lockForgetUpdate.Unlock()
	return mock.ForgetUpdateFunc(ctx, update)
}

// ForgetUpdateCalls gets all the calls that were made to ForgetUpdate.
// Check the length with:
//
//	len(mockedUpdateSourcePort.ForgetUpdateCalls())
func (mock *UpdateSourcePortMock) ForgetUpdateCalls() []struct {
	Ctx    context.Context
	Update provisioning.Update
} {
	var calls []struct {
		Ctx    context.Context
		Update provisioning.Update
	}
	mock.lockForgetUpdate.RLock()
	calls = mock.calls.ForgetUpdate
	mock.lockForgetUpdate.RUnlock()
	return calls
}

// GetLatest calls GetLatestFunc.
func (mock *UpdateSourcePortMock) GetLatest(ctx context.Context, limit int) (provisioning.Updates, error) {
	if mock.GetLatestFunc == nil {
		panic("UpdateSourcePortMock.GetLatestFunc: method is nil but UpdateSourcePort.GetLatest was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int
	}{
		Ctx:   ctx,
		Limit: limit,
	}
	mock.lockGetLatest.Lock()
	mock.calls.GetLatest = append(mock.calls.GetLatest, callInfo)
	mock.lockGetLatest.Unlock()
	return mock.GetLatestFunc(ctx, limit)
}

// GetLatestCalls gets all the calls that were made to GetLatest.
// Check the length with:
//
//	len(mockedUpdateSourcePort.GetLatestCalls())
func (mock *UpdateSourcePortMock) GetLatestCalls() []struct {
	Ctx   context.Context
	Limit int
} {
	var calls []struct {
		Ctx   context.Context
		Limit int
	}
	mock.lockGetLatest.RLock()
	calls = mock.calls.GetLatest
	mock.lockGetLatest.RUnlock()
	return calls
}

// GetUpdateAllFiles calls GetUpdateAllFilesFunc.
func (mock *UpdateSourcePortMock) GetUpdateAllFiles(ctx context.Context, update provisioning.Update) (provisioning.UpdateFiles, error) {
	if mock.GetUpdateAllFilesFunc == nil {
		panic("UpdateSourcePortMock.GetUpdateAllFilesFunc: method is nil but UpdateSourcePort.GetUpdateAllFiles was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Update provisioning.Update
	}{
		Ctx:    ctx,
		Update: update,
	}
	mock.lockGetUpdateAllFiles.Lock()
	mock.calls.GetUpdateAllFiles = append(mock.calls.GetUpdateAllFiles, callInfo)
	mock.lockGetUpdateAllFiles.Unlock()
	return mock.GetUpdateAllFilesFunc(ctx, update)
}

// GetUpdateAllFilesCalls gets all the calls that were made to GetUpdateAllFiles.
// Check the length with:
//
//	len(mockedUpdateSourcePort.GetUpdateAllFilesCalls())
func (mock *UpdateSourcePortMock) GetUpdateAllFilesCalls() []struct {
	Ctx    context.Context
	Update provisioning.Update
} {
	var calls []struct {
		Ctx    context.Context
		Update provisioning.Update
	}
	mock.lockGetUpdateAllFiles.RLock()
	calls = mock.calls.GetUpdateAllFiles
	mock.lockGetUpdateAllFiles.RUnlock()
	return calls
}

// GetUpdateFileByFilename calls GetUpdateFileByFilenameFunc.
func (mock *UpdateSourcePortMock) GetUpdateFileByFilename(ctx context.Context, update provisioning.Update, filename string) (io.ReadCloser, int, error) {
	if mock.GetUpdateFileByFilenameFunc == nil {
		panic("UpdateSourcePortMock.GetUpdateFileByFilenameFunc: method is nil but UpdateSourcePort.GetUpdateFileByFilename was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Update   provisioning.Update
		Filename string
	}{
		Ctx:      ctx,
		Update:   update,
		Filename: filename,
	}
	mock.lockGetUpdateFileByFilename.Lock()
	mock.calls.GetUpdateFileByFilename = append(mock.calls.GetUpdateFileByFilename, callInfo)
	mock.lockGetUpdateFileByFilename.Unlock()
	return mock.GetUpdateFileByFilenameFunc(ctx, update, filename)
}

// GetUpdateFileByFilenameCalls gets all the calls that were made to GetUpdateFileByFilename.
// Check the length with:
//
//	len(mockedUpdateSourcePort.GetUpdateFileByFilenameCalls())
func (mock *UpdateSourcePortMock) GetUpdateFileByFilenameCalls() []struct {
	Ctx      context.Context
	Update   provisioning.Update
	Filename string
} {
	var calls []struct {
		Ctx      context.Context
		Update   provisioning.Update
		Filename string
	}
	mock.lockGetUpdateFileByFilename.RLock()
	calls = mock.calls.GetUpdateFileByFilename
	mock.lockGetUpdateFileByFilename.RUnlock()
	return calls
}
