// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mock

import (
	"context"
	"io"
	"sync"

	"github.com/FuturFusion/operations-center/internal/provisioning"
)

// Ensure that ClusterProvisioningPortMock does implement provisioning.ClusterProvisioningPort.
// If this is not the case, regenerate this file with mockery.
var _ provisioning.ClusterProvisioningPort = &ClusterProvisioningPortMock{}

// ClusterProvisioningPortMock is a mock implementation of provisioning.ClusterProvisioningPort.
//
//	func TestSomethingThatUsesClusterProvisioningPort(t *testing.T) {
//
//		// make and configure a mocked provisioning.ClusterProvisioningPort
//		mockedClusterProvisioningPort := &ClusterProvisioningPortMock{
//			ApplyFunc: func(ctx context.Context, cluster provisioning.Cluster) error {
//				panic("mock out the Apply method")
//			},
//			GetArchiveFunc: func(ctx context.Context, name string) (io.ReadCloser, int, error) {
//				panic("mock out the GetArchive method")
//			},
//			InitFunc: func(ctx context.Context, name string, config provisioning.ClusterProvisioningConfig) error {
//				panic("mock out the Init method")
//			},
//		}
//
//		// use mockedClusterProvisioningPort in code that requires provisioning.ClusterProvisioningPort
//		// and then make assertions.
//
//	}
type ClusterProvisioningPortMock struct {
	// ApplyFunc mocks the Apply method.
	ApplyFunc func(ctx context.Context, cluster provisioning.Cluster) error

	// GetArchiveFunc mocks the GetArchive method.
	GetArchiveFunc func(ctx context.Context, name string) (io.ReadCloser, int, error)

	// InitFunc mocks the Init method.
	InitFunc func(ctx context.Context, name string, config provisioning.ClusterProvisioningConfig) error

	// calls tracks calls to the methods.
	calls struct {
		// Apply holds details about calls to the Apply method.
		Apply []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cluster is the cluster argument value.
			Cluster provisioning.Cluster
		}
		// GetArchive holds details about calls to the GetArchive method.
		GetArchive []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// Init holds details about calls to the Init method.
		Init []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Config is the config argument value.
			Config provisioning.ClusterProvisioningConfig
		}
	}
	lockApply      sync.RWMutex
	lockGetArchive sync.RWMutex
	lockInit       sync.RWMutex
}

// Apply calls ApplyFunc.
func (mock *ClusterProvisioningPortMock) Apply(ctx context.Context, cluster provisioning.Cluster) error {
	if mock.ApplyFunc == nil {
		panic("ClusterProvisioningPortMock.ApplyFunc: method is nil but ClusterProvisioningPort.Apply was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Cluster provisioning.Cluster
	}{
		Ctx:     ctx,
		Cluster: cluster,
	}
	mock.lockApply.Lock()
	mock.calls.Apply = append(mock.calls.Apply, callInfo)
	mock.lockApply.Unlock()
	return mock.ApplyFunc(ctx, cluster)
}

// ApplyCalls gets all the calls that were made to Apply.
// Check the length with:
//
//	len(mockedClusterProvisioningPort.ApplyCalls())
func (mock *ClusterProvisioningPortMock) ApplyCalls() []struct {
	Ctx     context.Context
	Cluster provisioning.Cluster
} {
	var calls []struct {
		Ctx     context.Context
		Cluster provisioning.Cluster
	}
	mock.lockApply.RLock()
	calls = mock.calls.Apply
	mock.lockApply.RUnlock()
	return calls
}

// GetArchive calls GetArchiveFunc.
func (mock *ClusterProvisioningPortMock) GetArchive(ctx context.Context, name string) (io.ReadCloser, int, error) {
	if mock.GetArchiveFunc == nil {
		panic("ClusterProvisioningPortMock.GetArchiveFunc: method is nil but ClusterProvisioningPort.GetArchive was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockGetArchive.Lock()
	mock.calls.GetArchive = append(mock.calls.GetArchive, callInfo)
	mock.lockGetArchive.Unlock()
	return mock.GetArchiveFunc(ctx, name)
}

// GetArchiveCalls gets all the calls that were made to GetArchive.
// Check the length with:
//
//	len(mockedClusterProvisioningPort.GetArchiveCalls())
func (mock *ClusterProvisioningPortMock) GetArchiveCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockGetArchive.RLock()
	calls = mock.calls.GetArchive
	mock.lockGetArchive.RUnlock()
	return calls
}

// Init calls InitFunc.
func (mock *ClusterProvisioningPortMock) Init(ctx context.Context, name string, config provisioning.ClusterProvisioningConfig) error {
	if mock.InitFunc == nil {
		panic("ClusterProvisioningPortMock.InitFunc: method is nil but ClusterProvisioningPort.Init was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Name   string
		Config provisioning.ClusterProvisioningConfig
	}{
		Ctx:    ctx,
		Name:   name,
		Config: config,
	}
	mock.lockInit.Lock()
	mock.calls.Init = append(mock.calls.Init, callInfo)
	mock.lockInit.Unlock()
	return mock.InitFunc(ctx, name, config)
}

// InitCalls gets all the calls that were made to Init.
// Check the length with:
//
//	len(mockedClusterProvisioningPort.InitCalls())
func (mock *ClusterProvisioningPortMock) InitCalls() []struct {
	Ctx    context.Context
	Name   string
	Config provisioning.ClusterProvisioningConfig
} {
	var calls []struct {
		Ctx    context.Context
		Name   string
		Config provisioning.ClusterProvisioningConfig
	}
	mock.lockInit.RLock()
	calls = mock.calls.Init
	mock.lockInit.RUnlock()
	return calls
}
