// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mock

import (
	"context"
	"sync"

	"github.com/FuturFusion/operations-center/internal/provisioning"
)

// Ensure that ClusterProvisioningPortMock does implement provisioning.ClusterProvisioningPort.
// If this is not the case, regenerate this file with mockery.
var _ provisioning.ClusterProvisioningPort = &ClusterProvisioningPortMock{}

// ClusterProvisioningPortMock is a mock implementation of provisioning.ClusterProvisioningPort.
//
//	func TestSomethingThatUsesClusterProvisioningPort(t *testing.T) {
//
//		// make and configure a mocked provisioning.ClusterProvisioningPort
//		mockedClusterProvisioningPort := &ClusterProvisioningPortMock{
//			ApplyFunc: func(ctx context.Context, cluster provisioning.Cluster) error {
//				panic("mock out the Apply method")
//			},
//			InitFunc: func(ctx context.Context, clusterName string, config provisioning.ClusterProvisioningConfig) (string, func() error, error) {
//				panic("mock out the Init method")
//			},
//		}
//
//		// use mockedClusterProvisioningPort in code that requires provisioning.ClusterProvisioningPort
//		// and then make assertions.
//
//	}
type ClusterProvisioningPortMock struct {
	// ApplyFunc mocks the Apply method.
	ApplyFunc func(ctx context.Context, cluster provisioning.Cluster) error

	// InitFunc mocks the Init method.
	InitFunc func(ctx context.Context, clusterName string, config provisioning.ClusterProvisioningConfig) (string, func() error, error)

	// calls tracks calls to the methods.
	calls struct {
		// Apply holds details about calls to the Apply method.
		Apply []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cluster is the cluster argument value.
			Cluster provisioning.Cluster
		}
		// Init holds details about calls to the Init method.
		Init []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ClusterName is the clusterName argument value.
			ClusterName string
			// Config is the config argument value.
			Config provisioning.ClusterProvisioningConfig
		}
	}
	lockApply sync.RWMutex
	lockInit  sync.RWMutex
}

// Apply calls ApplyFunc.
func (mock *ClusterProvisioningPortMock) Apply(ctx context.Context, cluster provisioning.Cluster) error {
	if mock.ApplyFunc == nil {
		panic("ClusterProvisioningPortMock.ApplyFunc: method is nil but ClusterProvisioningPort.Apply was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Cluster provisioning.Cluster
	}{
		Ctx:     ctx,
		Cluster: cluster,
	}
	mock.lockApply.Lock()
	mock.calls.Apply = append(mock.calls.Apply, callInfo)
	mock.lockApply.Unlock()
	return mock.ApplyFunc(ctx, cluster)
}

// ApplyCalls gets all the calls that were made to Apply.
// Check the length with:
//
//	len(mockedClusterProvisioningPort.ApplyCalls())
func (mock *ClusterProvisioningPortMock) ApplyCalls() []struct {
	Ctx     context.Context
	Cluster provisioning.Cluster
} {
	var calls []struct {
		Ctx     context.Context
		Cluster provisioning.Cluster
	}
	mock.lockApply.RLock()
	calls = mock.calls.Apply
	mock.lockApply.RUnlock()
	return calls
}

// Init calls InitFunc.
func (mock *ClusterProvisioningPortMock) Init(ctx context.Context, clusterName string, config provisioning.ClusterProvisioningConfig) (string, func() error, error) {
	if mock.InitFunc == nil {
		panic("ClusterProvisioningPortMock.InitFunc: method is nil but ClusterProvisioningPort.Init was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ClusterName string
		Config      provisioning.ClusterProvisioningConfig
	}{
		Ctx:         ctx,
		ClusterName: clusterName,
		Config:      config,
	}
	mock.lockInit.Lock()
	mock.calls.Init = append(mock.calls.Init, callInfo)
	mock.lockInit.Unlock()
	return mock.InitFunc(ctx, clusterName, config)
}

// InitCalls gets all the calls that were made to Init.
// Check the length with:
//
//	len(mockedClusterProvisioningPort.InitCalls())
func (mock *ClusterProvisioningPortMock) InitCalls() []struct {
	Ctx         context.Context
	ClusterName string
	Config      provisioning.ClusterProvisioningConfig
} {
	var calls []struct {
		Ctx         context.Context
		ClusterName string
		Config      provisioning.ClusterProvisioningConfig
	}
	mock.lockInit.RLock()
	calls = mock.calls.Init
	mock.lockInit.RUnlock()
	return calls
}
