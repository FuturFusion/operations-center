package api_test

import (
	"bytes"
	"context"
	"crypto/tls"
	"encoding/json"
	"io"
	"net"
	"net/http"
	"path/filepath"
	"testing"
	"time"

	incustls "github.com/lxc/incus/v6/shared/tls"
	"github.com/stretchr/testify/require"

	"github.com/FuturFusion/operations-center/internal/api"
	config "github.com/FuturFusion/operations-center/internal/config/daemon"
	"github.com/FuturFusion/operations-center/internal/environment/mock"
	shared "github.com/FuturFusion/operations-center/shared/api"
)

// Test PUT /1.0/system/certificate.
func TestSystemCertificatePut(t *testing.T) {
	// Setup daemon
	tmpDir := t.TempDir()

	ctx := context.Background()

	env := &mock.EnvironmentMock{
		IsIncusOSFunc: func() bool {
			return false
		},
		GetUnixSocketFunc: func() string {
			return filepath.Join(tmpDir, "unix.socket")
		},
		VarDirFunc: func() string {
			return tmpDir
		},
		UsrShareDirFunc: func() string {
			return tmpDir
		},
		GetTokenFunc: func(ctx context.Context) (string, error) {
			return "", nil
		},
	}

	config.InitTest(t, env, nil, config.InternalConfig{
		IsBackgroundTasksDisabled: true,
		SourcePollSkipFirst:       true,
	})
	err := config.UpdateNetwork(ctx, shared.SystemNetworkPut{
		OperationsCenterAddress: "https://127.0.0.1:17443",
		RestServerAddress:       "[::1]:17443",
	})
	require.NoError(t, err)

	d := api.NewDaemon(
		ctx,
		env,
	)

	err = d.Start(ctx)
	require.NoError(t, err)
	t.Cleanup(func() {
		err = d.Stop(context.Background())
		require.NoError(t, err)
	})

	// http client, used to get the server certificate.
	client := http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
			},
		},
	}

	// unix socket client, bypass authentication and authorization.
	socketClient := &http.Client{
		Transport: &http.Transport{
			DialContext: func(_ context.Context, _, _ string) (net.Conn, error) {
				return net.Dial("unix", filepath.Join(tmpDir, "unix.socket"))
			},
		},
	}

	// Execute tests

	// 1. Get certificate auto generated by daemon during startup
	resp1, err := client.Get("https://localhost:17443")
	require.NoError(t, err)
	defer resp1.Body.Close()

	initialCertificateSerialNumber := resp1.TLS.PeerCertificates[0].SerialNumber.String()

	// 2. Update certificate
	certPEM, keyPEM, err := incustls.GenerateMemCert(false, false)
	require.NoError(t, err)

	systemCertificatePost := shared.SystemCertificatePost{
		Certificate: string(certPEM),
		Key:         string(keyPEM),
	}

	cert, err := tls.X509KeyPair(certPEM, keyPEM)
	require.NoError(t, err)

	requestBody, err := json.Marshal(systemCertificatePost)
	require.NoError(t, err)

	req, err := http.NewRequest(http.MethodPost, "http://unix/1.0/system/certificate", bytes.NewBuffer(requestBody))

	resp2, err := socketClient.Do(req)
	require.NoError(t, err)
	defer resp2.Body.Close()

	body, err := io.ReadAll(resp2.Body)
	require.NoError(t, err)
	require.Contains(t, string(body), `"Success"`)

	// Update of server certificate is async, leave a little bit headroom for the server to update the certificate in the background.
	time.Sleep(10 * time.Millisecond)

	// 3. Get certificate after update
	resp3, err := client.Get("https://localhost:17443")
	require.NoError(t, err)
	defer resp3.Body.Close()

	updatedCertificateSerialNumber := resp3.TLS.PeerCertificates[0].SerialNumber.String()

	// Assert results

	require.NotEqual(t, initialCertificateSerialNumber, updatedCertificateSerialNumber)
	require.Equal(t, cert.Leaf.SerialNumber.String(), updatedCertificateSerialNumber)
}
