// Code generated by generate-expr. DO NOT EDIT.

package inventory

import (
	"reflect"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

func populate(t *testing.T, v reflect.Value, depth map[reflect.Type]int, maxDepth int) {
	t.Helper()

	switch v.Kind() {
	case reflect.Array:
		for i := 0; i < v.Len(); i++ {
			populate(t, v.Index(i), depth, maxDepth)
		}

	case reflect.Interface:
		v.Set(reflect.ValueOf("any"))
	case reflect.String:
		v.SetString("test")
	case reflect.Bool:
		v.SetBool(true)
	case reflect.Float32, reflect.Float64:
		v.SetFloat(123)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v.SetInt(123)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		v.SetUint(123)
	case reflect.Map:
		v.Set(reflect.MakeMap(v.Type()))
		key := reflect.New(v.Type().Key()).Elem()
		val := reflect.New(v.Type().Elem()).Elem()
		populate(t, key, depth, maxDepth)
		populate(t, val, depth, maxDepth)
		v.SetMapIndex(key, val)

	case reflect.Pointer:
		v.Set(reflect.New(v.Type().Elem()))
		populate(t, v.Elem(), depth, maxDepth)

	case reflect.Slice:
		if v.Type().String() == "json.RawMessage" {
			v.Set(reflect.ValueOf([]byte("{}")))
		} else {
			slice := reflect.MakeSlice(v.Type(), 1, 1)
			populate(t, slice.Index(0), depth, maxDepth)
			v.Set(slice)
		}

	case reflect.Struct:
		if depth[v.Type()] > maxDepth {
			t.Logf("Skipping recursive %v after %d iterations\n", v.Type(), maxDepth)
			v.Set(reflect.Zero(v.Type()))
			for i := 0; i < v.NumField(); i++ {
				// Instantiate nils before aborting recursive structs to mimic the behaviour of ToExpr for equality checks.
				if v.Field(i).Kind() == reflect.Pointer && v.Field(i).CanSet() {
					v := v.Field(i)
					v.Set(reflect.New(v.Type().Elem()))
				}
			}
		} else {
			// Only count non-stdlib packages for recursion.
			if strings.Contains(v.Type().PkgPath(), "/") {
				depth[v.Type()] = depth[v.Type()] + 1
			}

			for i := 0; i < v.NumField(); i++ {
				if v.Field(i).CanSet() {
					populate(t, v.Field(i), depth, maxDepth)
				}
			}
		}

	default:
		require.Failf(t, "Unexpected reflect.Kind", "Kind: %v Name: %v", v.Kind(), v.Type().Name())
	}
}
