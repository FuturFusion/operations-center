package main

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"go/format"
	"io/fs"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
	"github.com/spf13/pflag"

	"github.com/FuturFusion/operations-center/internal/logger"
	"github.com/FuturFusion/operations-center/internal/maps"
)

//go:embed tmpl
var templateFS embed.FS

const generatedByPreamble = `// Code generated by generate-inventory; DO NOT EDIT.

`

// FileType represents a specific type of file.
type FileType string

const (
	FileTypeGo  FileType = "go"
	FileTypeTS  FileType = "ts"
	FileTypeTSX FileType = "tsx"
)

var targets = []struct {
	TemplateName   string
	TargetName     string
	TargetFileType FileType
}{
	{
		TemplateName:   "api.gotmpl",
		TargetName:     "internal/api/api_inventory_{{ .Name }}_gen.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "client_test.gotmpl",
		TargetName:     "internal/client/inventory_{{ .Name }}_gen_test.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "client.gotmpl",
		TargetName:     "internal/client/inventory_{{ .Name }}_gen.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "cmds.gotmpl",
		TargetName:     "internal/cli/cmds/inventory/{{ .Name }}_gen.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "model_test.gotmpl",
		TargetName:     "internal/inventory/{{ .Name }}_model_gen_test.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "model.gotmpl",
		TargetName:     "internal/inventory/{{ .Name }}_model_gen.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "ports.gotmpl",
		TargetName:     "internal/inventory/{{ .Name }}_ports_gen.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "server_incus.gotmpl",
		TargetName:     "internal/inventory/server/incus/{{ .Name }}_gen.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "server_incus_test.gotmpl",
		TargetName:     "internal/inventory/server/incus/{{ .Name }}_gen_test.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "repo_sqlite_entities.gotmpl",
		TargetName:     "internal/inventory/repo/sqlite/entities/{{ .Name }}_gen.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "repo_sqlite_test.gotmpl",
		TargetName:     "internal/inventory/repo/sqlite/{{ .Name }}_gen_test.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "repo_sqlite.gotmpl",
		TargetName:     "internal/inventory/repo/sqlite/{{ .Name }}_gen.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "service_internal_test.gotmpl",
		TargetName:     "internal/inventory/{{ .Name }}_service_internal_gen_test.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "service_test.gotmpl",
		TargetName:     "internal/inventory/{{ .Name }}_service_gen_test.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "service.gotmpl",
		TargetName:     "internal/inventory/{{ .Name }}_service_gen.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "shared_api.gotmpl",
		TargetName:     "shared/api/inventory_{{ .Name }}_gen.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "ui_types.gotmpl",
		TargetName:     "ui/src/types/{{ .Name }}_gen.d.ts",
		TargetFileType: FileTypeTS,
	},
	{
		TemplateName:   "ui_api.gotmpl",
		TargetName:     "ui/src/api/{{ .Name }}_gen.tsx",
		TargetFileType: FileTypeTSX,
	},
}

var globalTargets = []struct {
	TemplateName string
	TargetName   string
}{
	{
		TemplateName: "api_inventory_aggregate.gotmpl",
		TargetName:   "shared/api/api_aggregate_gen.go",
	},
	{
		TemplateName: "api_inventory_query_helper.gotmpl",
		TargetName:   "internal/api/api_inventory_query_helper_gen.go",
	},
	{
		TemplateName: "api_inventory.gotmpl",
		TargetName:   "internal/api/api_inventory_gen.go",
	},
	{
		TemplateName: "cmds_inventory.gotmpl",
		TargetName:   "internal/cli/cmds/inventory_gen.go",
	},
	{
		TemplateName: "inventory_aggregate_model.gotmpl",
		TargetName:   "internal/inventory/inventory_aggregate_model_gen.go",
	},
	{
		TemplateName: "inventory_ports.gotmpl",
		TargetName:   "internal/inventory/ports_gen.go",
	},
	{
		TemplateName: "populate_db.gotmpl",
		TargetName:   "cmd/populate-db/main_gen.go",
	},
	{
		TemplateName: "seed_config.gotmpl",
		TargetName:   "internal/dbschema/seed/config_gen.go",
	},
	{
		TemplateName: "server_incus_testcases.gotmpl",
		TargetName:   "internal/inventory/server/incus/client_testcases_gen_test.go",
	},
}

type entityArgs struct {
	Name                   string
	RequiresExtension      string
	PluralName             string
	ObjectType             string
	ObjectEmbedded         bool
	ObjectNamePropertyName string
	ObjectDisplayName      string
	HasProject             bool
	HasProjectDirect       bool
	HasProjectFromParent   bool
	UsesEmbeddedPostType   bool
	ServerIDByLocation     bool
	IsServerIDOptional     bool
	IsServerIDDefining     bool
	IncusGetAllMethod      string
	IncusGetMethod         string
	HasParent              bool
	ParentName             string
	ParentPluralName       string
	ParentObjectType       string
	ExtraAttributes        []ExtraAttribute
	DisplayAttributes      []DisplayAttribute
	ColumnPipelines        []ColumnPipeline
	HasSyncFilter          bool
	HasParentFilter        bool
}

func main() {
	ctx := context.Background()

	flagConfigFile := pflag.String("config", "generate-inventory.yaml", "filename of the configfile")
	flagLogDebug := pflag.BoolP("debug", "d", false, "Show all debug messages")
	flagLogVerbose := pflag.BoolP("verbose", "v", false, "Show all information messages")

	flagOnlyTemplate := pflag.String("only-template", "", "limit code generation to this template")
	flagOnlyEntity := pflag.String("only-entity", "", "limit code generateion to this entity")

	pflag.Parse()

	err := logger.InitLogger(os.Stderr, "", *flagLogVerbose, *flagLogDebug)
	die(err)

	slog.DebugContext(ctx, "config file", slog.String("filename", *flagConfigFile))

	var cfg Config
	err = cfg.LoadConfig(*flagConfigFile)
	die(err)

	allEntities := make(map[string]entityArgs, len(cfg))

	for name, entity := range maps.OrderedByKey(cfg) {
		if entity.PluralName == "" {
			cfg[name].PluralName = name + "s"
		}

		if entity.ObjectNamePropertyName == "" {
			cfg[name].ObjectNamePropertyName = "Name"
		}

		if entity.ObjectDisplayName == "" {
			cfg[name].ObjectDisplayName = "Name"
		}

		if entity.ObjectType != "" {
			cfg[name].ObjectEmbedded = true
		}

		if entity.ObjectType == "" {
			cfg[name].ObjectType = name
		}

		if entity.ParentPluralName == "" {
			cfg[name].ParentPluralName = entity.ParentName + "s"
		}

		if entity.ParentObjectType == "" {
			cfg[name].ParentObjectType = entity.ParentName
		}

		slog.DebugContext(ctx, "entity config", slog.String("name", name), slog.Any("config", entity))
	}

	funcsMap := sprig.FuncMap()
	funcsMap["pascalcase"] = PascalCase
	funcsMap["pascalcaseWithoutAcronyms"] = PascalCaseWithoutAcronyms
	funcsMap["camelcase"] = CamelCase
	funcsMap["kebabcase"] = KebabCase
	funcsMap["titlecase"] = TitleCase
	funcsMap["words"] = Words

	t := template.New("")
	t = t.Funcs(funcsMap)
	t, err = t.ParseFS(templateFS, "tmpl/*.gotmpl")
	die(err)

	for name, entity := range maps.OrderedByKey(cfg) {
		args := entityArgs{
			Name:                   name,
			RequiresExtension:      entity.RequiresExtension,
			PluralName:             entity.PluralName,
			ObjectType:             entity.ObjectType,
			ObjectEmbedded:         entity.ObjectEmbedded,
			ObjectNamePropertyName: entity.ObjectNamePropertyName,
			ObjectDisplayName:      entity.ObjectDisplayName,
			HasProject:             entity.ProjectSource == ProjectSourceDirect || entity.ProjectSource == ProjectSourceParent,
			HasProjectDirect:       entity.ProjectSource == ProjectSourceDirect,
			HasProjectFromParent:   entity.ProjectSource == ProjectSourceParent,
			UsesEmbeddedPostType:   entity.UsesEmbeddedPostType,
			ServerIDByLocation:     entity.ServerIDByLocation,
			IsServerIDOptional:     entity.IsServerIDOptional,
			IsServerIDDefining:     !entity.IsServerIDNotDefining,
			IncusGetAllMethod:      entity.IncusGetAllMethod,
			IncusGetMethod:         entity.IncusGetMethod,
			HasParent:              entity.ParentName != "",
			ParentName:             entity.ParentName,
			ParentPluralName:       entity.ParentPluralName,
			ParentObjectType:       entity.ParentObjectType,
			ExtraAttributes:        entity.ExtraAttributes,
			DisplayAttributes:      entity.DisplayAttributes,
			ColumnPipelines:        entity.ColumnPipelines,
			HasSyncFilter:          entity.HasSyncFilter,
			HasParentFilter:        entity.HasParentFilter,
		}

		allEntities[name] = args

		if *flagOnlyEntity != "" && *flagOnlyEntity != name {
			continue
		}

		for _, target := range targets {
			if *flagOnlyTemplate != "" && *flagOnlyTemplate != target.TemplateName {
				continue
			}

			slog.InfoContext(ctx, "generating", slog.String("name", args.Name), slog.String("template", target.TemplateName))

			filename := strings.Builder{}

			filenameTmpl, err := template.New("name").Funcs(funcsMap).Parse(target.TargetName)
			die(err)

			err = filenameTmpl.Execute(&filename, args)
			die(err)

			targetDir := filepath.Dir(filename.String())
			if !directoryExists(targetDir) {
				err = os.MkdirAll(targetDir, 0o700)
				die(err)
			}

			buf := bytes.Buffer{}

			_, err = buf.WriteString(generatedByPreamble)
			die(err)

			err = t.ExecuteTemplate(&buf, target.TemplateName, args)
			die(err)

			formattedSource := buf.Bytes()
			if target.TargetFileType == FileTypeGo {
				formattedSource, err = format.Source(buf.Bytes())
				if err != nil {
					formattedSource = buf.Bytes()
					slog.ErrorContext(ctx, "failed to format source", slog.Any("err", err), slog.String("target_filename", filename.String()))
				}
			}

			err = os.WriteFile(filename.String(), formattedSource, 0o600)
			die(err)
		}
	}

	t = template.New("")
	t = t.Funcs(funcsMap)
	t, err = t.ParseFS(templateFS, "tmpl/global/*.gotmpl")
	die(err)

	for _, target := range globalTargets {
		if *flagOnlyTemplate != "" && *flagOnlyTemplate != target.TemplateName {
			continue
		}

		slog.InfoContext(ctx, "generating global", slog.String("template", target.TemplateName))

		targetDir := filepath.Dir(target.TargetName)
		if !directoryExists(targetDir) {
			err = os.MkdirAll(targetDir, 0o700)
			die(err)
		}

		buf := bytes.Buffer{}

		_, err = buf.WriteString(generatedByPreamble)
		die(err)

		err = t.ExecuteTemplate(&buf, target.TemplateName, allEntities)
		die(err)

		formattedSource, err := format.Source(buf.Bytes())
		if err != nil {
			formattedSource = buf.Bytes()
			slog.ErrorContext(ctx, "failed to format source", slog.Any("err", err), slog.String("target_filename", target.TargetName))
		}

		err = os.WriteFile(target.TargetName, formattedSource, 0o600)
		die(err)
	}
}

// die is a convenience function to end the processing with a panic in the case of an error.
func die(err error) {
	if err != nil {
		slog.ErrorContext(context.Background(), "generate-inventory failed", slog.Any("err", err))
		panic("die")
	}
}

// directoryExists returns true, if the given path does exist and is of type
// directory. Symlinks are resolved, sucht that the effective target is checked.
// Otherwise false is returned.
func directoryExists(name string) bool {
	info, err := os.Stat(name)
	if err != nil && errors.Is(err, fs.ErrNotExist) {
		return false
	}

	return info.IsDir()
}
