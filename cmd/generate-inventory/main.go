package main

import (
	"bytes"
	"cmp"
	"context"
	"embed"
	"go/format"
	"iter"
	"log/slog"
	"os"
	"sort"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
	"github.com/spf13/pflag"

	"github.com/FuturFusion/operations-center/internal/logger"
)

//go:embed tmpl
var templateFS embed.FS

const generatedByPreamble = `// Code generated by generate-inventory; DO NOT EDIT.

`

var targets = []struct {
	TemplateName string
	TargetName   string
}{
	{
		TemplateName: "api.gotmpl",
		TargetName:   "cmd/operations-centerd/internal/api/api_inventory_{{ .Name }}.go",
	},
	{
		TemplateName: "model_test.gotmpl",
		TargetName:   "internal/inventory/{{ .Name }}_model_test.go",
	},
	{
		TemplateName: "model.gotmpl",
		TargetName:   "internal/inventory/{{ .Name }}_model.go",
	},
	{
		TemplateName: "ports.gotmpl",
		TargetName:   "internal/inventory/{{ .Name }}_ports.go",
	},
	{
		TemplateName: "server_incus.gotmpl",
		TargetName:   "internal/inventory/server/incus/{{ .Name }}.go",
	},
	{
		TemplateName: "repo_sqlite_test.gotmpl",
		TargetName:   "internal/inventory/repo/sqlite/{{ .Name }}_test.go",
	},
	{
		TemplateName: "repo_sqlite.gotmpl",
		TargetName:   "internal/inventory/repo/sqlite/{{ .Name }}.go",
	},
	{
		TemplateName: "service_internal_test.gotmpl",
		TargetName:   "internal/inventory/{{ .Name }}_service_internal_test.go",
	},
	{
		TemplateName: "service_test.gotmpl",
		TargetName:   "internal/inventory/{{ .Name }}_service_test.go",
	},
	{
		TemplateName: "service.gotmpl",
		TargetName:   "internal/inventory/{{ .Name }}_service.go",
	},
	{
		TemplateName: "shared_api.gotmpl",
		TargetName:   "shared/api/inventory_{{ .Name }}.go",
	},
}

func main() {
	ctx := context.Background()

	flagConfigFile := pflag.String("config", "generate-inventory.yaml", "filename of the configfile")
	flagLogDebug := pflag.BoolP("debug", "d", false, "Show all debug messages")
	flagLogVerbose := pflag.BoolP("verbose", "v", false, "Show all information messages")

	flagOnlyTemplate := pflag.String("only-template", "", "limit code generation to this template")
	flagOnlyEntity := pflag.String("only-entity", "", "limit code generateion to this entity")

	pflag.Parse()

	err := logger.InitLogger(os.Stderr, "", *flagLogVerbose, *flagLogDebug)
	die(err)

	slog.DebugContext(ctx, "config file", slog.String("filename", *flagConfigFile))

	var cfg Config
	err = cfg.LoadConfig(*flagConfigFile)
	die(err)

	for name, entity := range orderedByKey(cfg) {
		if entity.PluralName == "" {
			cfg[name].PluralName = name + "s"
		}

		if entity.ObjectNamePropertyName == "" {
			cfg[name].ObjectNamePropertyName = "Name"
		}

		if entity.ObjectType != "" {
			cfg[name].ObjectEmbedded = true
		}

		if entity.ObjectType == "" {
			cfg[name].ObjectType = name
		}

		if entity.ParentPluralName == "" {
			cfg[name].ParentPluralName = entity.ParentName + "s"
		}

		if entity.ParentObjectType == "" {
			cfg[name].ParentObjectType = entity.ParentName
		}

		slog.DebugContext(ctx, "entity config", slog.String("name", name), slog.Any("config", entity))
	}

	funcsMap := sprig.FuncMap()
	funcsMap["pascalcase"] = PascalCase
	funcsMap["camelcase"] = CamelCase

	t := template.New("")
	t = t.Funcs(funcsMap)
	t, err = t.ParseFS(templateFS, "tmpl/*.gotmpl")
	die(err)

	for name, entity := range orderedByKey(cfg) {
		if *flagOnlyEntity != "" && *flagOnlyEntity != name {
			continue
		}

		args := struct {
			Name                   string
			PluralName             string
			ObjectType             string
			ObjectEmbedded         bool
			ObjectNamePropertyName string
			HasProject             bool
			UsesEmbeddedPostType   bool
			HasLocation            bool
			IncusGetAllMethod      string
			IncusGetMethod         string
			HasParent              bool
			ParentName             string
			ParentPluralName       string
			ParentObjectType       string
			ExtraAttributes        []ExtraAttribute
		}{
			Name:                   name,
			PluralName:             entity.PluralName,
			ObjectType:             entity.ObjectType,
			ObjectEmbedded:         entity.ObjectEmbedded,
			ObjectNamePropertyName: entity.ObjectNamePropertyName,
			HasProject:             !entity.OmitProject,
			UsesEmbeddedPostType:   entity.UsesEmbeddedPostType,
			HasLocation:            entity.HasLocation,
			IncusGetAllMethod:      entity.IncusGetAllMethod,
			IncusGetMethod:         entity.IncusGetMethod,
			HasParent:              entity.ParentName != "",
			ParentName:             entity.ParentName,
			ParentPluralName:       entity.ParentPluralName,
			ParentObjectType:       entity.ParentObjectType,
			ExtraAttributes:        entity.ExtraAttributes,
		}

		for _, target := range targets {
			if *flagOnlyTemplate != "" && *flagOnlyTemplate != target.TemplateName {
				continue
			}

			slog.InfoContext(ctx, "generating", slog.String("name", args.Name), slog.String("template", target.TemplateName))
			func() {
				filename := strings.Builder{}

				filenameTmpl, err := template.New("name").Funcs(funcsMap).Parse(target.TargetName)
				die(err)

				err = filenameTmpl.Execute(&filename, args)
				die(err)

				buf := bytes.Buffer{}

				_, err = buf.WriteString(generatedByPreamble)
				die(err)

				err = t.ExecuteTemplate(&buf, target.TemplateName, args)
				die(err)

				formattedSource, err := format.Source(buf.Bytes())
				if err != nil {
					formattedSource = buf.Bytes()
					slog.ErrorContext(ctx, "failed to format source", slog.Any("err", err), slog.String("target_filename", filename.String()))
				}

				err = os.WriteFile(filename.String(), formattedSource, 0o600)
				die(err)
			}()
		}
	}
}

// die is a convenience function to end the processing with a panic in the case of an error.
func die(err error) {
	if err != nil {
		slog.ErrorContext(context.Background(), "generate-inventory failed", slog.Any("err", err))
		panic("die")
	}
}

// orderedByKey returns an iterator to traverse a map ordered by key.
func orderedByKey[K cmp.Ordered, E any](m map[K]E) iter.Seq2[K, E] {
	return func(yield func(K, E) bool) {
		keys := make([]K, 0, len(m))
		for k := range m {
			keys = append(keys, k)
		}

		sort.Slice(keys, func(i, j int) bool {
			return keys[i] < keys[j]
		})

		for _, k := range keys {
			if !yield(k, m[k]) {
				return
			}
		}
	}
}
