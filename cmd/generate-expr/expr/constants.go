package expr

// GenerateComment is the comment indicating that the file is generated.
const GenerateComment = "// Code generated by generate-expr. DO NOT EDIT."

// FilePrefix is the prefix used for generated files.
const FilePrefix = "_expr_gen.go"

// TestFilePrefix is the prefix used for generated test files.
const TestFilePrefix = "_expr_gen_test.go"

// TestHelperFile holds helpers used for tests.
const TestHelperFile = "utils_expr_gen_test.go"

// HelperFile holds helpers used for ToExpr conversion.
const HelperFile = "utils_expr_gen.go"

// TestHelpers holds the content of the utils_expr_gen_test.go file.
const TestHelpers = `
// Code generated by generate-expr. DO NOT EDIT.

package %s

import (
	"reflect"
	"testing"
	"strings"

	"github.com/stretchr/testify/require"
)

func populate(t *testing.T, v reflect.Value, depth map[reflect.Type]int, maxDepth int) {
	t.Helper()

	switch v.Kind() {
	case reflect.Array:
		for i := 0; i < v.Len(); i++ {
			populate(t, v.Index(i), depth, maxDepth)
		}

	case reflect.Interface:
		v.Set(reflect.ValueOf("any"))
	case reflect.String:
		v.SetString("test")
	case reflect.Bool:
		v.SetBool(true)
	case reflect.Float32, reflect.Float64:
		v.SetFloat(123)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v.SetInt(123)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		v.SetUint(123)
	case reflect.Map:
		v.Set(reflect.MakeMap(v.Type()))
		key := reflect.New(v.Type().Key()).Elem()
		val := reflect.New(v.Type().Elem()).Elem()
		populate(t, key, depth, maxDepth)
		populate(t, val, depth, maxDepth)
		v.SetMapIndex(key, val)

	case reflect.Pointer:
		v.Set(reflect.New(v.Type().Elem()))
		populate(t, v.Elem(), depth, maxDepth)

	case reflect.Slice:
		if v.Type().String() == "json.RawMessage" {
			v.Set(reflect.ValueOf([]byte("{}")))
		} else {
			slice := reflect.MakeSlice(v.Type(), 1, 1)
			populate(t, slice.Index(0), depth, maxDepth)
			v.Set(slice)
		}

	case reflect.Struct:
		if depth[v.Type()] > maxDepth {
			t.Logf("Skipping recursive %%v after %%d iterations\n", v.Type(), maxDepth)
			v.Set(reflect.Zero(v.Type()))
			for i := 0; i < v.NumField(); i++ {
				// Instantiate nils before aborting recursive structs to mimic the behaviour of ToExpr for equality checks.
				if v.Field(i).Kind() == reflect.Pointer && v.Field(i).CanSet() {
					v := v.Field(i)
					v.Set(reflect.New(v.Type().Elem()))
				}
			}
		} else {
	    // Only count non-stdlib packages for recursion.
	    if strings.Contains(v.Type().PkgPath(), "/") {
				depth[v.Type()] = depth[v.Type()] + 1
			}

			for i := 0; i < v.NumField(); i++ {
				if v.Field(i).CanSet() {
					populate(t, v.Field(i), depth, maxDepth)
				}
			}
		}

	default:
		require.Failf(t, "Unexpected reflect.Kind", "Kind: %%v Name: %%v", v.Kind(), v.Type().Name())
	}
}
`

// UtilHelpers holds the content of the utils_expr_gen.go file.
const UtilHelpers = `
// Code generated by generate-expr. DO NOT EDIT.

package %s

func sliceConvert[X, Y any](b []Y, f func(Y) X) []X {
	a := []X{}
	for _, v := range b {
		a = append(a, f(v))
	}

	return a
}

func mapConvert[K comparable, X, Y any](b map[K]Y, f func(Y) X) map[K]X {
	a := map[K]X{}
	for k, v := range b {
		a[k] = f(v)
	}

	return a
}

func toPtr[T any](v T) *T {
	return &v
}

func fromPtr[T any](v *T) T {
	if v == nil {
		var zero T
		return zero
	}

	return *v
}
`

// UnitTestTemplate is the template for generating the ToExpr conversion helper unit test for a struct.
const UnitTestTemplate = `
// Code generated by generate-expr. DO NOT EDIT.

package %s

func Test_ToExpr%s(t *testing.T) {
	obj := &%s{}
	populate(t, reflect.ValueOf(obj).Elem(), map[reflect.Type]int{}, 3)
	exp := ToExpr%s(*obj)

	objBytes, err := json.Marshal(obj)
	require.NoError(t, err)
	expBytes, err := json.Marshal(exp)
	require.NoError(t, err)
	require.Equal(t, objBytes, expBytes)
}
`
